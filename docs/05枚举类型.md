### 枚举类型

案例：

![image-20210316163910845](/Users/striveman/Library/Application Support/typora-user-images/image-20210316163910845.png)



如何解决上述问题，可以使用Ts中的枚举类型



#### 什么是枚举呢？

枚举：一组有名字的常量集合



```ts
//枚举类型

// * 1.数字枚举

//取值从0开始，后面的枚举成员会递增。也可以自定义枚举成员的初始值 。比如下面的Developer =3
enum Role {
  Reporter,
  Developer = 3,
  Maintainer,
  Owner,
  Guest,
}
//枚举其实就是对象。 对于数字枚举的对象进行了反向映射（既可以用枚举成员的名字来索引，也可以用值来索引），枚举成员的key作为了对象key，枚举成员的值也作为了对象的key。
console.log(Role);

// 我们可以将上面的枚举例子copy到ts官网的playGround去看一下他编译成了 https://www.typescriptlang.org/play

// 枚举被编译成了一个对象，首先枚举成员的名称被作为了key，枚举成员的值被作为了value，这个表达式直接返回了value。然后返回的value又被作为了key，成员的名称又作为了value 。这种方法被成为反向映射
// * 2.字符串枚举
// 只有成员的名称被作为了key。并且对于中文字母全部转变成了unicode编码。字符串枚举不能进行反向映射的。

enum Message {
  Sucess = "恭喜你，成功了",
  Fail = "抱歉，失败了",
}

// * 3.异构枚举
// 数字枚举和字符串枚举混用就构成了异构枚举
// ! 这种情况容易引起混淆，不建议使用
enum Answer {
  N,
  Y = "Yes",
}

// * 4.枚举成员

//  1. 枚举成员的值是只读类型，当我们定义后就不能再次修改了。
// Role.Reporter =2;

// 2. 枚举成员的分类
// (1) const number 常量枚举成员 常量枚举分为下面三种情况：
//  没有初始值的枚举成员、对已有枚举成员的引用、常量对表达式

// (2)computed number 计算枚举成员。 需要被计算的枚举成员。是一些非常量的表达式。 这些枚举成员的值不会在编译阶段进行计算。而是会保留到程序执行阶段
enum Char {
  a,
  b = Char.a,
  c = 1 + 3,
  //上述三种为常量枚举，常量枚举成员会在编译的阶段计算出结果，然后以常量的形式存在于运行时环境中

  // 下面是computed number 枚举成员
  d = Math.random(),
  e = '123'.length,
  // !我们需要注意的是。在computed number后的枚举成员一定要赋上初始值,如果没有就会报错
}

// * 5.常量枚举
//用const声明的枚举就是一个常量枚举
// ! 常量枚举又一个特点，就是会在编译阶段被移除
const enum Month{
  Jan,
  Feb,
  Mar
}
console.log('常量枚举'+Month.Feb);

// 那么常量枚举的作用是什么呢？
// 当我们不需要对象，而是需要对象的值的时候就可以使用常量枚举，这样会减少我们在编译环境的代码

// 例子：
let month = [Month.Jan,Month.Feb,Month.Mar];
console.log(month);//[0, 1, 2] //这样的话我们在编码的时候也能更好的语义化，在运行时候的代码也比较简洁

//* 6. 枚举类型, 在某些情况下枚举和枚举成员都可以成为单独的类型存在
// 情况1：枚举成员都没有初始值
enum E{a,b}
// 情况2: 所有成员都是数字枚举
enum F{a=0,b=1}
// 情况3:所有成员都是字符串枚举
enum G{a='apple',b='banana'}

//下面我们定义俩个枚举类型
let e:E = 3 //可以任意的number类型赋值给枚举类型（除去上面的字符串枚举外）
let f:F = 4 //取值也可以超出枚举成员的定义
// let g:G =5; //报错

//俩种不同类型的枚举是不能比较的 
// e===f

//下面定义了三种枚举成员类型
let e1:E.a =1
let e2:E.b
// e1 ===e2 //是不可以比较的
let e3:E.a =1

// e1和e3是相同的枚举成员类型。是可以进行比较的
console.log(e1,e3);
console.log(e1 === e3);

//而字符串枚举的取值只能是枚举成员的类型

let g1:G =G.a;
let g2:G.a =G.a; // 这赋值只能是她本身了



```



